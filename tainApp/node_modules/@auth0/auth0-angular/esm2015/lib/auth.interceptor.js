import { from, of, iif } from 'rxjs';
import { Injectable } from '@angular/core';
import { isHttpInterceptorRouteConfig, AuthClientConfig, } from './auth.config';
import { switchMap, first, concatMap, pluck } from 'rxjs/operators';
import { AuthService } from './auth.service';
export class AuthHttpInterceptor {
    constructor(configFactory, authService) {
        this.configFactory = configFactory;
        this.authService = authService;
    }
    intercept(req, next) {
        var _a;
        const config = this.configFactory.get();
        if (!((_a = config.httpInterceptor) === null || _a === void 0 ? void 0 : _a.allowedList)) {
            return next.handle(req);
        }
        return this.findMatchingRoute(req, config).pipe(concatMap((route) => iif(
        // Check if a route was matched
        () => route !== null, 
        // If we have a matching route, call getTokenSilently and attach the token to the
        // outgoing request
        of(route).pipe(pluck('tokenOptions'), concatMap((options) => this.authService.getAccessTokenSilently(options)), switchMap((token) => {
            // Clone the request and attach the bearer token
            const clone = req.clone({
                headers: req.headers.set('Authorization', `Bearer ${token}`),
            });
            return next.handle(clone);
        })), 
        // If the URI being called was not found in our httpInterceptor config, simply
        // pass the request through without attaching a token
        next.handle(req))));
    }
    /**
     * Strips the query and fragment from the given uri
     * @param uri The uri to remove the query and fragment from
     */
    stripQueryFrom(uri) {
        if (uri.indexOf('?') > -1) {
            uri = uri.substr(0, uri.indexOf('?'));
        }
        if (uri.indexOf('#') > -1) {
            uri = uri.substr(0, uri.indexOf('#'));
        }
        return uri;
    }
    /**
     * Determines whether the specified route can have an access token attached to it, based on matching the HTTP request against
     * the interceptor route configuration.
     * @param route The route to test
     * @param request The HTTP request
     */
    canAttachToken(route, request) {
        const testPrimitive = (value) => {
            if (value) {
                value.trim();
            }
            if (!value) {
                return false;
            }
            const requestPath = this.stripQueryFrom(request.url);
            if (value === requestPath) {
                return true;
            }
            // If the URL ends with an asterisk, match using startsWith.
            if (value.indexOf('*') === value.length - 1 &&
                request.url.startsWith(value.substr(0, value.length - 1))) {
                return true;
            }
        };
        if (isHttpInterceptorRouteConfig(route)) {
            if (route.httpMethod && route.httpMethod !== request.method) {
                return false;
            }
            return testPrimitive(route.uri);
        }
        return testPrimitive(route);
    }
    /**
     * Tries to match a route from the SDK configuration to the HTTP request.
     * If a match is found, the route configuration is returned.
     * @param request The Http request
     */
    findMatchingRoute(request, config) {
        return from(config.httpInterceptor.allowedList).pipe(first((route) => this.canAttachToken(route, request), null));
    }
}
AuthHttpInterceptor.decorators = [
    { type: Injectable }
];
AuthHttpInterceptor.ctorParameters = () => [
    { type: AuthClientConfig },
    { type: AuthService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiIvVXNlcnMvZnJlZGVyaWtwcmlqY2svRGV2ZWxvcG1lbnQvYXV0aDAtYW5ndWxhci9wcm9qZWN0cy9hdXRoMC1hbmd1bGFyL3NyYy8iLCJzb3VyY2VzIjpbImxpYi9hdXRoLmludGVyY2VwdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQU9BLE9BQU8sRUFBYyxJQUFJLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNqRCxPQUFPLEVBQUUsVUFBVSxFQUFVLE1BQU0sZUFBZSxDQUFDO0FBRW5ELE9BQU8sRUFHTCw0QkFBNEIsRUFDNUIsZ0JBQWdCLEdBRWpCLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFHN0MsTUFBTSxPQUFPLG1CQUFtQjtJQUM5QixZQUNVLGFBQStCLEVBQy9CLFdBQXdCO1FBRHhCLGtCQUFhLEdBQWIsYUFBYSxDQUFrQjtRQUMvQixnQkFBVyxHQUFYLFdBQVcsQ0FBYTtJQUMvQixDQUFDO0lBRUosU0FBUyxDQUNQLEdBQXFCLEVBQ3JCLElBQWlCOztRQUVqQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3hDLElBQUksUUFBQyxNQUFNLENBQUMsZUFBZSwwQ0FBRSxXQUFXLENBQUEsRUFBRTtZQUN4QyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDekI7UUFFRCxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUM3QyxTQUFTLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUNsQixHQUFHO1FBQ0QsK0JBQStC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Q0FBQyxDQUFDLElBQUksQ0FDbEQsS0FBSyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FDNUQsQ0FBQztJQUNKLENBQUM7OztZQXRIRixVQUFVOzs7WUFQVCxnQkFBZ0I7WUFLVCxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSHR0cEludGVyY2VwdG9yLFxuICBIdHRwUmVxdWVzdCxcbiAgSHR0cEhhbmRsZXIsXG4gIEh0dHBFdmVudCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBmcm9tLCBvZiwgaWlmIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHtcbiAgSHR0cEludGVyY2VwdG9yUm91dGVDb25maWcsXG4gIEFwaVJvdXRlRGVmaW5pdGlvbixcbiAgaXNIdHRwSW50ZXJjZXB0b3JSb3V0ZUNvbmZpZyxcbiAgQXV0aENsaWVudENvbmZpZyxcbiAgQXV0aENvbmZpZyxcbn0gZnJvbSAnLi9hdXRoLmNvbmZpZyc7XG5cbmltcG9ydCB7IHN3aXRjaE1hcCwgZmlyc3QsIGNvbmNhdE1hcCwgcGx1Y2sgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBBdXRoU2VydmljZSB9IGZyb20gJy4vYXV0aC5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEF1dGhIdHRwSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNvbmZpZ0ZhY3Rvcnk6IEF1dGhDbGllbnRDb25maWcsXG4gICAgcHJpdmF0ZSBhdXRoU2VydmljZTogQXV0aFNlcnZpY2VcbiAgKSB7fVxuXG4gIGludGVyY2VwdChcbiAgICByZXE6IEh0dHBSZXF1ZXN0PGFueT4sXG4gICAgbmV4dDogSHR0cEhhbmRsZXJcbiAgKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnRmFjdG9yeS5nZXQoKTtcbiAgICBpZiAoIWNvbmZpZy5odHRwSW50ZXJjZXB0b3I/LmFsbG93ZWRMaXN0KSB7XG4gICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5kTWF0Y2hpbmdSb3V0ZShyZXEsIGNvbmZpZykucGlwZShcbiAgICAgIGNvbmNhdE1hcCgocm91dGUpID0+XG4gICAgICAgIGlpZihcbiAgICAgICAgICAvLyBDaGVjayBpZiBhIHJvdXRlIHdhcyBtYXRjaGVkXG4gICAgICAgICAgKCkgPT4gcm91dGUgIT09IG51bGwsXG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG1hdGNoaW5nIHJvdXRlLCBjYWxsIGdldFRva2VuU2lsZW50bHkgYW5kIGF0dGFjaCB0aGUgdG9rZW4gdG8gdGhlXG4gICAgICAgICAgLy8gb3V0Z29pbmcgcmVxdWVzdFxuICAgICAgICAgIG9mKHJvdXRlKS5waXBlKFxuICAgICAgICAgICAgcGx1Y2soJ3Rva2VuT3B0aW9ucycpLFxuICAgICAgICAgICAgY29uY2F0TWFwKChvcHRpb25zKSA9PlxuICAgICAgICAgICAgICB0aGlzLmF1dGhTZXJ2aWNlLmdldEFjY2Vzc1Rva2VuU2lsZW50bHkob3B0aW9ucylcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKHRva2VuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIHJlcXVlc3QgYW5kIGF0dGFjaCB0aGUgYmVhcmVyIHRva2VuXG4gICAgICAgICAgICAgIGNvbnN0IGNsb25lID0gcmVxLmNsb25lKHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXEuaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7dG9rZW59YCksXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHJldHVybiBuZXh0LmhhbmRsZShjbG9uZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgICAgLy8gSWYgdGhlIFVSSSBiZWluZyBjYWxsZWQgd2FzIG5vdCBmb3VuZCBpbiBvdXIgaHR0cEludGVyY2VwdG9yIGNvbmZpZywgc2ltcGx5XG4gICAgICAgICAgLy8gcGFzcyB0aGUgcmVxdWVzdCB0aHJvdWdoIHdpdGhvdXQgYXR0YWNoaW5nIGEgdG9rZW5cbiAgICAgICAgICBuZXh0LmhhbmRsZShyZXEpXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0cmlwcyB0aGUgcXVlcnkgYW5kIGZyYWdtZW50IGZyb20gdGhlIGdpdmVuIHVyaVxuICAgKiBAcGFyYW0gdXJpIFRoZSB1cmkgdG8gcmVtb3ZlIHRoZSBxdWVyeSBhbmQgZnJhZ21lbnQgZnJvbVxuICAgKi9cbiAgcHJpdmF0ZSBzdHJpcFF1ZXJ5RnJvbSh1cmk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHVyaS5pbmRleE9mKCc/JykgPiAtMSkge1xuICAgICAgdXJpID0gdXJpLnN1YnN0cigwLCB1cmkuaW5kZXhPZignPycpKTtcbiAgICB9XG5cbiAgICBpZiAodXJpLmluZGV4T2YoJyMnKSA+IC0xKSB7XG4gICAgICB1cmkgPSB1cmkuc3Vic3RyKDAsIHVyaS5pbmRleE9mKCcjJykpO1xuICAgIH1cblxuICAgIHJldHVybiB1cmk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgcm91dGUgY2FuIGhhdmUgYW4gYWNjZXNzIHRva2VuIGF0dGFjaGVkIHRvIGl0LCBiYXNlZCBvbiBtYXRjaGluZyB0aGUgSFRUUCByZXF1ZXN0IGFnYWluc3RcbiAgICogdGhlIGludGVyY2VwdG9yIHJvdXRlIGNvbmZpZ3VyYXRpb24uXG4gICAqIEBwYXJhbSByb3V0ZSBUaGUgcm91dGUgdG8gdGVzdFxuICAgKiBAcGFyYW0gcmVxdWVzdCBUaGUgSFRUUCByZXF1ZXN0XG4gICAqL1xuICBwcml2YXRlIGNhbkF0dGFjaFRva2VuKFxuICAgIHJvdXRlOiBBcGlSb3V0ZURlZmluaXRpb24sXG4gICAgcmVxdWVzdDogSHR0cFJlcXVlc3Q8YW55PlxuICApOiBib29sZWFuIHtcbiAgICBjb25zdCB0ZXN0UHJpbWl0aXZlID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZS50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXF1ZXN0UGF0aCA9IHRoaXMuc3RyaXBRdWVyeUZyb20ocmVxdWVzdC51cmwpO1xuXG4gICAgICBpZiAodmFsdWUgPT09IHJlcXVlc3RQYXRoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgVVJMIGVuZHMgd2l0aCBhbiBhc3RlcmlzaywgbWF0Y2ggdXNpbmcgc3RhcnRzV2l0aC5cbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWUuaW5kZXhPZignKicpID09PSB2YWx1ZS5sZW5ndGggLSAxICYmXG4gICAgICAgIHJlcXVlc3QudXJsLnN0YXJ0c1dpdGgodmFsdWUuc3Vic3RyKDAsIHZhbHVlLmxlbmd0aCAtIDEpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoaXNIdHRwSW50ZXJjZXB0b3JSb3V0ZUNvbmZpZyhyb3V0ZSkpIHtcbiAgICAgIGlmIChyb3V0ZS5odHRwTWV0aG9kICYmIHJvdXRlLmh0dHBNZXRob2QgIT09IHJlcXVlc3QubWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRlc3RQcmltaXRpdmUocm91dGUudXJpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVzdFByaW1pdGl2ZShyb3V0ZSk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZXMgdG8gbWF0Y2ggYSByb3V0ZSBmcm9tIHRoZSBTREsgY29uZmlndXJhdGlvbiB0byB0aGUgSFRUUCByZXF1ZXN0LlxuICAgKiBJZiBhIG1hdGNoIGlzIGZvdW5kLCB0aGUgcm91dGUgY29uZmlndXJhdGlvbiBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHJlcXVlc3QgVGhlIEh0dHAgcmVxdWVzdFxuICAgKi9cbiAgcHJpdmF0ZSBmaW5kTWF0Y2hpbmdSb3V0ZShcbiAgICByZXF1ZXN0OiBIdHRwUmVxdWVzdDxhbnk+LFxuICAgIGNvbmZpZzogQXV0aENvbmZpZ1xuICApOiBPYnNlcnZhYmxlPEh0dHBJbnRlcmNlcHRvclJvdXRlQ29uZmlnPiB7XG4gICAgcmV0dXJuIGZyb20oY29uZmlnLmh0dHBJbnRlcmNlcHRvci5hbGxvd2VkTGlzdCkucGlwZShcbiAgICAgIGZpcnN0KChyb3V0ZSkgPT4gdGhpcy5jYW5BdHRhY2hUb2tlbihyb3V0ZSwgcmVxdWVzdCksIG51bGwpXG4gICAgKTtcbiAgfVxufVxuIl19